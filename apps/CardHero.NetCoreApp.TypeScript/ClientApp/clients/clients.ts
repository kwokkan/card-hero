/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.1.2.0 (NJsonSchema v10.0.24.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export interface IAccountApiClient {
    get(): Promise<UserModel>;
}

export class AccountApiClient extends CardHeroApiClientBase implements IAccountApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    get(): Promise<UserModel> {
        let url_ = this.baseUrl + "/api/account";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<UserModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorViewModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorViewModel.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }
}

export interface ICardApiClient {
    get(ids?: number[] | null | undefined, name?: string | null | undefined, page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<CardModel[]>;
}

export class CardApiClient extends CardHeroApiClientBase implements ICardApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    get(ids?: number[] | null | undefined, name?: string | null | undefined, page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<CardModel[]> {
        let url_ = this.baseUrl + "/api/cards?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<CardModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CardModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CardModel[]>(<any>null);
    }
}

export interface ICollectionApiClient {
    get(ids?: number[] | null | undefined, page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<CardCollectionModel[]>;
}

export class CollectionApiClient extends CardHeroApiClientBase implements ICollectionApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    get(ids?: number[] | null | undefined, page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<CardCollectionModel[]> {
        let url_ = this.baseUrl + "/api/collections?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<CardCollectionModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CardCollectionModel.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorViewModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CardCollectionModel[]>(<any>null);
    }
}

export interface IDeckApiClient {
    get(ids?: number[] | null | undefined, name?: string | null | undefined, page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<DeckModel[]>;
    create(model: DeckModel): Promise<DeckModel>;
    getById(id: number): Promise<DeckModel>;
}

export class DeckApiClient extends CardHeroApiClientBase implements IDeckApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    get(ids?: number[] | null | undefined, name?: string | null | undefined, page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<DeckModel[]> {
        let url_ = this.baseUrl + "/api/decks?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<DeckModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorViewModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeckModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeckModel[]>(<any>null);
    }

    create(model: DeckModel): Promise<DeckModel> {
        let url_ = this.baseUrl + "/api/decks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<DeckModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorViewModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = DeckModel.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeckModel>(<any>null);
    }

    getById(id: number): Promise<DeckModel> {
        let url_ = this.baseUrl + "/api/decks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<DeckModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorViewModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeckModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorViewModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeckModel>(<any>null);
    }
}

export interface IGameApiClient {
    get(gameId?: number | null | undefined, name?: string | null | undefined, startTime?: Date | null | undefined, endTime?: Date | null | undefined, playerCount?: number | null | undefined, activeOnly?: boolean | undefined, type?: GameType | null | undefined, page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<GameModel[]>;
    post(model: GameCreateModel): Promise<GameModel>;
    getById(id: number): Promise<GameViewModel>;
    join(id: number, model: JoinGameViewModel): Promise<GameUserModel>;
    move(id: number, model: GameTripleTriadMoveViewModel): Promise<GameTripleTriadMoveViewModel>;
}

export class GameApiClient extends CardHeroApiClientBase implements IGameApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    get(gameId?: number | null | undefined, name?: string | null | undefined, startTime?: Date | null | undefined, endTime?: Date | null | undefined, playerCount?: number | null | undefined, activeOnly?: boolean | undefined, type?: GameType | null | undefined, page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<GameModel[]> {
        let url_ = this.baseUrl + "/api/games?";
        if (gameId !== undefined)
            url_ += "GameId=" + encodeURIComponent("" + gameId) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (playerCount !== undefined)
            url_ += "PlayerCount=" + encodeURIComponent("" + playerCount) + "&"; 
        if (activeOnly === null)
            throw new Error("The parameter 'activeOnly' cannot be null.");
        else if (activeOnly !== undefined)
            url_ += "ActiveOnly=" + encodeURIComponent("" + activeOnly) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<GameModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GameModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameModel[]>(<any>null);
    }

    post(model: GameCreateModel): Promise<GameModel> {
        let url_ = this.baseUrl + "/api/games";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<GameModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = GameModel.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorViewModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameModel>(<any>null);
    }

    getById(id: number): Promise<GameViewModel> {
        let url_ = this.baseUrl + "/api/games/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<GameViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorViewModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameViewModel>(<any>null);
    }

    join(id: number, model: JoinGameViewModel): Promise<GameUserModel> {
        let url_ = this.baseUrl + "/api/games/{id}/join";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processJoin(_response);
        });
    }

    protected processJoin(response: Response): Promise<GameUserModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameUserModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameUserModel>(<any>null);
    }

    move(id: number, model: GameTripleTriadMoveViewModel): Promise<GameTripleTriadMoveViewModel> {
        let url_ = this.baseUrl + "/api/games/{id}/move";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMove(_response);
        });
    }

    protected processMove(response: Response): Promise<GameTripleTriadMoveViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = GameTripleTriadMoveViewModel.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorViewModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorViewModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameTripleTriadMoveViewModel>(<any>null);
    }
}

export interface IStoreApiClient {
    get(page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<StoreItemModel[]>;
    buyStoreItem(storeItem: StoreItemModel): Promise<CardCollectionModel[]>;
}

export class StoreApiClient extends CardHeroApiClientBase implements IStoreApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    get(page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<StoreItemModel[]> {
        let url_ = this.baseUrl + "/api/store?";
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<StoreItemModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StoreItemModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StoreItemModel[]>(<any>null);
    }

    buyStoreItem(storeItem: StoreItemModel): Promise<CardCollectionModel[]> {
        let url_ = this.baseUrl + "/api/store";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(storeItem);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBuyStoreItem(_response);
        });
    }

    protected processBuyStoreItem(response: Response): Promise<CardCollectionModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201!.push(CardCollectionModel.fromJS(item));
            }
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorViewModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CardCollectionModel[]>(<any>null);
    }
}

/** User. */
export class UserModel implements IUserModel {
    /** Id. */
    id?: number;
    /** Identifier. */
    identifier?: string | undefined;
    /** Created date. */
    createdDate?: Date;
    /** Full name. */
    fullName?: string | undefined;
    /** Identity provider source. */
    idPsource?: string | undefined;
    /** Coins this user has. */
    coins?: number;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.identifier = data["identifier"];
            this.createdDate = data["createdDate"] ? new Date(data["createdDate"].toString()) : <any>undefined;
            this.fullName = data["fullName"];
            this.idPsource = data["idPsource"];
            this.coins = data["coins"];
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["identifier"] = this.identifier;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["fullName"] = this.fullName;
        data["idPsource"] = this.idPsource;
        data["coins"] = this.coins;
        return data; 
    }
}

/** User. */
export interface IUserModel {
    /** Id. */
    id?: number;
    /** Identifier. */
    identifier?: string | undefined;
    /** Created date. */
    createdDate?: Date;
    /** Full name. */
    fullName?: string | undefined;
    /** Identity provider source. */
    idPsource?: string | undefined;
    /** Coins this user has. */
    coins?: number;
}

export class ErrorViewModel implements IErrorViewModel {
    message?: string | undefined;
    stackTrace?: string[] | undefined;

    constructor(data?: IErrorViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["message"];
            if (Array.isArray(data["stackTrace"])) {
                this.stackTrace = [] as any;
                for (let item of data["stackTrace"])
                    this.stackTrace!.push(item);
            }
        }
    }

    static fromJS(data: any): ErrorViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        if (Array.isArray(this.stackTrace)) {
            data["stackTrace"] = [];
            for (let item of this.stackTrace)
                data["stackTrace"].push(item);
        }
        return data; 
    }
}

export interface IErrorViewModel {
    message?: string | undefined;
    stackTrace?: string[] | undefined;
}

/** Card. */
export class CardModel implements ICardModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Description. */
    description?: string | undefined;
    /** Up attack. */
    upAttack?: number;
    /** Right attack. */
    rightAttack?: number;
    /** Down attack. */
    downAttack?: number;
    /** Left attack. */
    leftAttack?: number;
    /** Health. */
    health?: number;
    /** Attack. */
    attack?: number;
    /** Defence. */
    defence?: number;
    /** Total stats. */
    totalStats?: number;
    /** Is favourited. */
    isFavourited?: boolean;
    /** Rarity. */
    rarity?: Rarity;

    constructor(data?: ICardModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.description = data["description"];
            this.upAttack = data["upAttack"];
            this.rightAttack = data["rightAttack"];
            this.downAttack = data["downAttack"];
            this.leftAttack = data["leftAttack"];
            this.health = data["health"];
            this.attack = data["attack"];
            this.defence = data["defence"];
            this.totalStats = data["totalStats"];
            this.isFavourited = data["isFavourited"];
            this.rarity = data["rarity"];
        }
    }

    static fromJS(data: any): CardModel {
        data = typeof data === 'object' ? data : {};
        let result = new CardModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["upAttack"] = this.upAttack;
        data["rightAttack"] = this.rightAttack;
        data["downAttack"] = this.downAttack;
        data["leftAttack"] = this.leftAttack;
        data["health"] = this.health;
        data["attack"] = this.attack;
        data["defence"] = this.defence;
        data["totalStats"] = this.totalStats;
        data["isFavourited"] = this.isFavourited;
        data["rarity"] = this.rarity;
        return data; 
    }
}

/** Card. */
export interface ICardModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Description. */
    description?: string | undefined;
    /** Up attack. */
    upAttack?: number;
    /** Right attack. */
    rightAttack?: number;
    /** Down attack. */
    downAttack?: number;
    /** Left attack. */
    leftAttack?: number;
    /** Health. */
    health?: number;
    /** Attack. */
    attack?: number;
    /** Defence. */
    defence?: number;
    /** Total stats. */
    totalStats?: number;
    /** Is favourited. */
    isFavourited?: boolean;
    /** Rarity. */
    rarity?: Rarity;
}

/** Rarity. */
export enum Rarity {
    Common = 1,
    Uncommon = 2,
    Rare = 3,
    Epic = 4,
    Legendary = 5,
}

/** Card collection. */
export class CardCollectionModel implements ICardCollectionModel {
    /** Id. */
    id?: number;
    /** Card id. */
    cardId?: number;
    /** User id. */
    userId?: number;
    /** Card. */
    card?: CardModel | undefined;
    /** User. */
    user?: UserModel | undefined;

    constructor(data?: ICardCollectionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cardId = data["cardId"];
            this.userId = data["userId"];
            this.card = data["card"] ? CardModel.fromJS(data["card"]) : <any>undefined;
            this.user = data["user"] ? UserModel.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CardCollectionModel {
        data = typeof data === 'object' ? data : {};
        let result = new CardCollectionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cardId"] = this.cardId;
        data["userId"] = this.userId;
        data["card"] = this.card ? this.card.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

/** Card collection. */
export interface ICardCollectionModel {
    /** Id. */
    id?: number;
    /** Card id. */
    cardId?: number;
    /** User id. */
    userId?: number;
    /** Card. */
    card?: CardModel | undefined;
    /** User. */
    user?: UserModel | undefined;
}

/** Deck. */
export class DeckModel implements IDeckModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Description. */
    description?: string | undefined;
    /** Max cards. */
    maxCards?: number;
    /** Is favourited. */
    isFavourited?: boolean;
    /** List of cards. */
    cards?: DeckCardModel[] | undefined;

    constructor(data?: IDeckModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.description = data["description"];
            this.maxCards = data["maxCards"];
            this.isFavourited = data["isFavourited"];
            if (Array.isArray(data["cards"])) {
                this.cards = [] as any;
                for (let item of data["cards"])
                    this.cards!.push(DeckCardModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeckModel {
        data = typeof data === 'object' ? data : {};
        let result = new DeckModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["maxCards"] = this.maxCards;
        data["isFavourited"] = this.isFavourited;
        if (Array.isArray(this.cards)) {
            data["cards"] = [];
            for (let item of this.cards)
                data["cards"].push(item.toJSON());
        }
        return data; 
    }
}

/** Deck. */
export interface IDeckModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Description. */
    description?: string | undefined;
    /** Max cards. */
    maxCards?: number;
    /** Is favourited. */
    isFavourited?: boolean;
    /** List of cards. */
    cards?: DeckCardModel[] | undefined;
}

/** Deck caard. */
export class DeckCardModel extends CardModel implements IDeckCardModel {
    /** Card collection id. */
    cardCollectionId?: number;

    constructor(data?: IDeckCardModel) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.cardCollectionId = data["cardCollectionId"];
        }
    }

    static fromJS(data: any): DeckCardModel {
        data = typeof data === 'object' ? data : {};
        let result = new DeckCardModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cardCollectionId"] = this.cardCollectionId;
        super.toJSON(data);
        return data; 
    }
}

/** Deck caard. */
export interface IDeckCardModel extends ICardModel {
    /** Card collection id. */
    cardCollectionId?: number;
}

/** Game. */
export class GameModel implements IGameModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Sart time. */
    startTime?: Date;
    /** End time. */
    endTime?: Date | undefined;
    /** Users. */
    users?: GameUserModel[] | undefined;
    /** Turns. */
    turns?: TurnModel[] | undefined;
    /** Current user. */
    currentUser?: UserModel | undefined;
    /** Winner. */
    winner?: UserModel | undefined;
    /** Columns. */
    columns?: number;
    /** Rows. */
    rows?: number;
    /** Game type. */
    type?: GameType;
    /** Deck id. */
    deckId?: number;
    /** Deck. */
    deck?: DeckModel | undefined;
    /** Game deck id. */
    gameDeckId?: number;
    /** Game deck. */
    gameDeck?: GameDeckModel | undefined;
    /** Maximum number of people who can play the game. */
    maxUsers?: number;
    /** Whether a user can join this game. */
    canJoin?: boolean;
    /** Whether the user can make their move. */
    canPlay?: boolean;

    constructor(data?: IGameModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.startTime = data["startTime"] ? new Date(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? new Date(data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(data["users"])) {
                this.users = [] as any;
                for (let item of data["users"])
                    this.users!.push(GameUserModel.fromJS(item));
            }
            if (Array.isArray(data["turns"])) {
                this.turns = [] as any;
                for (let item of data["turns"])
                    this.turns!.push(TurnModel.fromJS(item));
            }
            this.currentUser = data["currentUser"] ? UserModel.fromJS(data["currentUser"]) : <any>undefined;
            this.winner = data["winner"] ? UserModel.fromJS(data["winner"]) : <any>undefined;
            this.columns = data["columns"];
            this.rows = data["rows"];
            this.type = data["type"];
            this.deckId = data["deckId"];
            this.deck = data["deck"] ? DeckModel.fromJS(data["deck"]) : <any>undefined;
            this.gameDeckId = data["gameDeckId"];
            this.gameDeck = data["gameDeck"] ? GameDeckModel.fromJS(data["gameDeck"]) : <any>undefined;
            this.maxUsers = data["maxUsers"];
            this.canJoin = data["canJoin"];
            this.canPlay = data["canPlay"];
        }
    }

    static fromJS(data: any): GameModel {
        data = typeof data === 'object' ? data : {};
        let result = new GameModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        if (Array.isArray(this.turns)) {
            data["turns"] = [];
            for (let item of this.turns)
                data["turns"].push(item.toJSON());
        }
        data["currentUser"] = this.currentUser ? this.currentUser.toJSON() : <any>undefined;
        data["winner"] = this.winner ? this.winner.toJSON() : <any>undefined;
        data["columns"] = this.columns;
        data["rows"] = this.rows;
        data["type"] = this.type;
        data["deckId"] = this.deckId;
        data["deck"] = this.deck ? this.deck.toJSON() : <any>undefined;
        data["gameDeckId"] = this.gameDeckId;
        data["gameDeck"] = this.gameDeck ? this.gameDeck.toJSON() : <any>undefined;
        data["maxUsers"] = this.maxUsers;
        data["canJoin"] = this.canJoin;
        data["canPlay"] = this.canPlay;
        return data; 
    }
}

/** Game. */
export interface IGameModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Sart time. */
    startTime?: Date;
    /** End time. */
    endTime?: Date | undefined;
    /** Users. */
    users?: GameUserModel[] | undefined;
    /** Turns. */
    turns?: TurnModel[] | undefined;
    /** Current user. */
    currentUser?: UserModel | undefined;
    /** Winner. */
    winner?: UserModel | undefined;
    /** Columns. */
    columns?: number;
    /** Rows. */
    rows?: number;
    /** Game type. */
    type?: GameType;
    /** Deck id. */
    deckId?: number;
    /** Deck. */
    deck?: DeckModel | undefined;
    /** Game deck id. */
    gameDeckId?: number;
    /** Game deck. */
    gameDeck?: GameDeckModel | undefined;
    /** Maximum number of people who can play the game. */
    maxUsers?: number;
    /** Whether a user can join this game. */
    canJoin?: boolean;
    /** Whether the user can make their move. */
    canPlay?: boolean;
}

/** User belonging to a game. */
export class GameUserModel implements IGameUserModel {
    /** Game user id. */
    id?: number;
    /** User id. */
    userId?: number;
    /** User. */
    user?: UserModel | undefined;
    /** Game id. */
    gameId?: number;
    /** Order of the players. */
    order?: number | undefined;

    constructor(data?: IGameUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userId = data["userId"];
            this.user = data["user"] ? UserModel.fromJS(data["user"]) : <any>undefined;
            this.gameId = data["gameId"];
            this.order = data["order"];
        }
    }

    static fromJS(data: any): GameUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new GameUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["gameId"] = this.gameId;
        data["order"] = this.order;
        return data; 
    }
}

/** User belonging to a game. */
export interface IGameUserModel {
    /** Game user id. */
    id?: number;
    /** User id. */
    userId?: number;
    /** User. */
    user?: UserModel | undefined;
    /** Game id. */
    gameId?: number;
    /** Order of the players. */
    order?: number | undefined;
}

/** Turn. */
export class TurnModel implements ITurnModel {
    /** Id. */
    id?: number;
    /** Start time. */
    startTime?: Date;
    /** End time. */
    endTime?: Date | undefined;
    /** User. */
    user?: UserModel | undefined;
    /** Game. */
    game?: GameModel | undefined;

    constructor(data?: ITurnModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.startTime = data["startTime"] ? new Date(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? new Date(data["endTime"].toString()) : <any>undefined;
            this.user = data["user"] ? UserModel.fromJS(data["user"]) : <any>undefined;
            this.game = data["game"] ? GameModel.fromJS(data["game"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TurnModel {
        data = typeof data === 'object' ? data : {};
        let result = new TurnModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["game"] = this.game ? this.game.toJSON() : <any>undefined;
        return data; 
    }
}

/** Turn. */
export interface ITurnModel {
    /** Id. */
    id?: number;
    /** Start time. */
    startTime?: Date;
    /** End time. */
    endTime?: Date | undefined;
    /** User. */
    user?: UserModel | undefined;
    /** Game. */
    game?: GameModel | undefined;
}

/** Type of game. */
export enum GameType {
    TripleTriad = 1,
}

/** Deck for use within a game. */
export class GameDeckModel implements IGameDeckModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Description. */
    description?: string | undefined;
    /** Game user id. */
    gameUserId?: number;

    constructor(data?: IGameDeckModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.description = data["description"];
            this.gameUserId = data["gameUserId"];
        }
    }

    static fromJS(data: any): GameDeckModel {
        data = typeof data === 'object' ? data : {};
        let result = new GameDeckModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["gameUserId"] = this.gameUserId;
        return data; 
    }
}

/** Deck for use within a game. */
export interface IGameDeckModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Description. */
    description?: string | undefined;
    /** Game user id. */
    gameUserId?: number;
}

export class GameViewModel extends GameModel implements IGameViewModel {
    data?: any | undefined;

    constructor(data?: IGameViewModel) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"];
        }
    }

    static fromJS(data: any): GameViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new GameViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        super.toJSON(data);
        return data; 
    }
}

export interface IGameViewModel extends IGameModel {
    data?: any | undefined;
}

/** Model for creating a new game. */
export class GameCreateModel implements IGameCreateModel {
    /** Name of game. */
    name?: string | undefined;
    /** Type of game. */
    type?: GameType;
    /** Deck to use. */
    deckId?: number;
    /** Users in game. */
    users?: UserModel[] | undefined;
    /** Current game user id. */
    currentGameUserId?: number;
    /** Max players in game. */
    maxPlayers?: number;
    /** Columns in game. */
    columns?: number;
    /** Rows in game. */
    rows?: number;

    constructor(data?: IGameCreateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.type = data["type"];
            this.deckId = data["deckId"];
            if (Array.isArray(data["users"])) {
                this.users = [] as any;
                for (let item of data["users"])
                    this.users!.push(UserModel.fromJS(item));
            }
            this.currentGameUserId = data["currentGameUserId"];
            this.maxPlayers = data["maxPlayers"];
            this.columns = data["columns"];
            this.rows = data["rows"];
        }
    }

    static fromJS(data: any): GameCreateModel {
        data = typeof data === 'object' ? data : {};
        let result = new GameCreateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["deckId"] = this.deckId;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        data["currentGameUserId"] = this.currentGameUserId;
        data["maxPlayers"] = this.maxPlayers;
        data["columns"] = this.columns;
        data["rows"] = this.rows;
        return data; 
    }
}

/** Model for creating a new game. */
export interface IGameCreateModel {
    /** Name of game. */
    name?: string | undefined;
    /** Type of game. */
    type?: GameType;
    /** Deck to use. */
    deckId?: number;
    /** Users in game. */
    users?: UserModel[] | undefined;
    /** Current game user id. */
    currentGameUserId?: number;
    /** Max players in game. */
    maxPlayers?: number;
    /** Columns in game. */
    columns?: number;
    /** Rows in game. */
    rows?: number;
}

export class JoinGameViewModel implements IJoinGameViewModel {
    deckId?: number;

    constructor(data?: IJoinGameViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deckId = data["deckId"];
        }
    }

    static fromJS(data: any): JoinGameViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new JoinGameViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deckId"] = this.deckId;
        return data; 
    }
}

export interface IJoinGameViewModel {
    deckId?: number;
}

export class GameTripleTriadMoveViewModel implements IGameTripleTriadMoveViewModel {
    row?: number;
    column?: number;
    cardCollectionId?: number;

    constructor(data?: IGameTripleTriadMoveViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.row = data["row"];
            this.column = data["column"];
            this.cardCollectionId = data["cardCollectionId"];
        }
    }

    static fromJS(data: any): GameTripleTriadMoveViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new GameTripleTriadMoveViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["row"] = this.row;
        data["column"] = this.column;
        data["cardCollectionId"] = this.cardCollectionId;
        return data; 
    }
}

export interface IGameTripleTriadMoveViewModel {
    row?: number;
    column?: number;
    cardCollectionId?: number;
}

/** Store item. */
export class StoreItemModel implements IStoreItemModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Description. */
    description?: string | undefined;
    /** Cost. */
    cost?: number;
    /** Item count. */
    itemCount?: number;
    /** Expiry. */
    expiry?: Date | undefined;

    constructor(data?: IStoreItemModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.description = data["description"];
            this.cost = data["cost"];
            this.itemCount = data["itemCount"];
            this.expiry = data["expiry"] ? new Date(data["expiry"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): StoreItemModel {
        data = typeof data === 'object' ? data : {};
        let result = new StoreItemModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["cost"] = this.cost;
        data["itemCount"] = this.itemCount;
        data["expiry"] = this.expiry ? this.expiry.toISOString() : <any>undefined;
        return data; 
    }
}

/** Store item. */
export interface IStoreItemModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Description. */
    description?: string | undefined;
    /** Cost. */
    cost?: number;
    /** Item count. */
    itemCount?: number;
    /** Expiry. */
    expiry?: Date | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}