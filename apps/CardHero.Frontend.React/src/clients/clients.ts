/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { CardHeroApiClientBase } from './CardHeroApiClientBase';

export interface IAccountApiClient {
    get(): Promise<UserModel>;
}

export class AccountApiClient extends CardHeroApiClientBase implements IAccountApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    get(): Promise<UserModel> {
        let url_ = this.baseUrl + "/api/account";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<UserModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorViewModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorViewModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorViewModel.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }
}

export interface ICardApiClient {
    get(ids?: number[] | null | undefined, name?: string | null | undefined, cardPackId?: number | null | undefined, page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<CardModel[]>;
    favourite(id: number): Promise<void>;
}

export class CardApiClient extends CardHeroApiClientBase implements ICardApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    get(ids?: number[] | null | undefined, name?: string | null | undefined, cardPackId?: number | null | undefined, page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<CardModel[]> {
        let url_ = this.baseUrl + "/api/cards?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (cardPackId !== undefined && cardPackId !== null)
            url_ += "CardPackId=" + encodeURIComponent("" + cardPackId) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<CardModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorViewModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CardModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CardModel[]>(<any>null);
    }

    favourite(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/cards/{id}/favourite";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFavourite(_response);
        });
    }

    protected processFavourite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorViewModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface ICardPackApiClient {
    get(): Promise<CardPackModel[]>;
}

export class CardPackApiClient extends CardHeroApiClientBase implements ICardPackApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    get(): Promise<CardPackModel[]> {
        let url_ = this.baseUrl + "/api/packs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<CardPackModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorViewModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CardPackModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CardPackModel[]>(<any>null);
    }
}

export interface ICollectionApiClient {
    get(name?: string | null | undefined, ids?: number[] | null | undefined, page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<CardCollectionModel[]>;
}

export class CollectionApiClient extends CardHeroApiClientBase implements ICollectionApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    get(name?: string | null | undefined, ids?: number[] | null | undefined, page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<CardCollectionModel[]> {
        let url_ = this.baseUrl + "/api/collections?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<CardCollectionModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorViewModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CardCollectionModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorViewModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CardCollectionModel[]>(<any>null);
    }
}

export interface IDeckApiClient {
    get(ids?: number[] | null | undefined, name?: string | null | undefined, page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<DeckModel[]>;
    create(model: DeckCreateModel): Promise<DeckModel>;
    getById(id: number): Promise<DeckModel>;
    patch(id: number, model: DeckModel): Promise<void>;
    favourite(id: number, model: DeckModel): Promise<void>;
}

export class DeckApiClient extends CardHeroApiClientBase implements IDeckApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    get(ids?: number[] | null | undefined, name?: string | null | undefined, page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<DeckModel[]> {
        let url_ = this.baseUrl + "/api/decks?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<DeckModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorViewModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorViewModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeckModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeckModel[]>(<any>null);
    }

    create(model: DeckCreateModel): Promise<DeckModel> {
        let url_ = this.baseUrl + "/api/decks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<DeckModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorViewModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorViewModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = DeckModel.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeckModel>(<any>null);
    }

    getById(id: number): Promise<DeckModel> {
        let url_ = this.baseUrl + "/api/decks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<DeckModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorViewModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorViewModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeckModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorViewModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeckModel>(<any>null);
    }

    patch(id: number, model: DeckModel): Promise<void> {
        let url_ = this.baseUrl + "/api/decks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPatch(_response);
        });
    }

    protected processPatch(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorViewModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorViewModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    favourite(id: number, model: DeckModel): Promise<void> {
        let url_ = this.baseUrl + "/api/decks/{id}/favourite";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFavourite(_response);
        });
    }

    protected processFavourite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorViewModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorViewModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface IGameApiClient {
    get(gameId?: number | null | undefined, name?: string | null | undefined, startTime?: Date | null | undefined, endTime?: Date | null | undefined, playerCount?: number | null | undefined, activeOnly?: boolean | undefined, type?: GameType | null | undefined, page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<GameModel[]>;
    post(model: GameCreateModel): Promise<GameModel>;
    getById(id: number): Promise<GameModel>;
    join(id: number, model: GameJoinModel): Promise<void>;
}

export class GameApiClient extends CardHeroApiClientBase implements IGameApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    get(gameId?: number | null | undefined, name?: string | null | undefined, startTime?: Date | null | undefined, endTime?: Date | null | undefined, playerCount?: number | null | undefined, activeOnly?: boolean | undefined, type?: GameType | null | undefined, page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<GameModel[]> {
        let url_ = this.baseUrl + "/api/games?";
        if (gameId !== undefined && gameId !== null)
            url_ += "GameId=" + encodeURIComponent("" + gameId) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (startTime !== undefined && startTime !== null)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (playerCount !== undefined && playerCount !== null)
            url_ += "PlayerCount=" + encodeURIComponent("" + playerCount) + "&";
        if (activeOnly === null)
            throw new Error("The parameter 'activeOnly' cannot be null.");
        else if (activeOnly !== undefined)
            url_ += "ActiveOnly=" + encodeURIComponent("" + activeOnly) + "&";
        if (type !== undefined && type !== null)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<GameModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorViewModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GameModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameModel[]>(<any>null);
    }

    post(model: GameCreateModel): Promise<GameModel> {
        let url_ = this.baseUrl + "/api/games";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<GameModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorViewModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = GameModel.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorViewModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameModel>(<any>null);
    }

    getById(id: number): Promise<GameModel> {
        let url_ = this.baseUrl + "/api/games/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<GameModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorViewModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorViewModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameModel>(<any>null);
    }

    join(id: number, model: GameJoinModel): Promise<void> {
        let url_ = this.baseUrl + "/api/games/{id}/join";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processJoin(_response);
        });
    }

    protected processJoin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorViewModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface IGamePlayApiClient {
    getById(id: number): Promise<GamePlayModel>;
    move(id: number, model: MoveModel): Promise<MoveModel>;
}

export class GamePlayApiClient extends CardHeroApiClientBase implements IGamePlayApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getById(id: number): Promise<GamePlayModel> {
        let url_ = this.baseUrl + "/api/play/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<GamePlayModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorViewModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GamePlayModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorViewModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GamePlayModel>(<any>null);
    }

    move(id: number, model: MoveModel): Promise<MoveModel> {
        let url_ = this.baseUrl + "/api/play/{id}/move";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMove(_response);
        });
    }

    protected processMove(response: Response): Promise<MoveModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorViewModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = MoveModel.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorViewModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorViewModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MoveModel>(<any>null);
    }
}

export interface IStoreApiClient {
    get(page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<StoreItemModel[]>;
    buyStoreItem(id: number): Promise<CardCollectionModel[]>;
}

export class StoreApiClient extends CardHeroApiClientBase implements IStoreApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    get(page?: number | null | undefined, pageSize?: number | null | undefined, sort?: string | null | undefined): Promise<StoreItemModel[]> {
        let url_ = this.baseUrl + "/api/store?";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<StoreItemModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorViewModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StoreItemModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StoreItemModel[]>(<any>null);
    }

    buyStoreItem(id: number): Promise<CardCollectionModel[]> {
        let url_ = this.baseUrl + "/api/store/{id}/buy";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBuyStoreItem(_response);
        });
    }

    protected processBuyStoreItem(response: Response): Promise<CardCollectionModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorViewModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201!.push(CardCollectionModel.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorViewModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CardCollectionModel[]>(<any>null);
    }
}

export class ErrorViewModel implements IErrorViewModel {
    message?: string | undefined;
    stackTrace?: string[] | undefined;

    constructor(data?: IErrorViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            if (Array.isArray(_data["stackTrace"])) {
                this.stackTrace = [] as any;
                for (let item of _data["stackTrace"])
                    this.stackTrace!.push(item);
            }
        }
    }

    static fromJS(data: any): ErrorViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        if (Array.isArray(this.stackTrace)) {
            data["stackTrace"] = [];
            for (let item of this.stackTrace)
                data["stackTrace"].push(item);
        }
        return data; 
    }
}

export interface IErrorViewModel {
    message?: string | undefined;
    stackTrace?: string[] | undefined;
}

/** User. */
export class UserModel implements IUserModel {
    /** Id. */
    id?: number;
    /** Identifier. */
    identifier?: string | undefined;
    /** Created date. */
    createdDate?: Date;
    /** Full name. */
    fullName?: string | undefined;
    /** Identity provider source. */
    idPsource?: string | undefined;
    /** Coins this user has. */
    coins?: number;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.identifier = _data["identifier"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.fullName = _data["fullName"];
            this.idPsource = _data["idPsource"];
            this.coins = _data["coins"];
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["identifier"] = this.identifier;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["fullName"] = this.fullName;
        data["idPsource"] = this.idPsource;
        data["coins"] = this.coins;
        return data; 
    }
}

/** User. */
export interface IUserModel {
    /** Id. */
    id?: number;
    /** Identifier. */
    identifier?: string | undefined;
    /** Created date. */
    createdDate?: Date;
    /** Full name. */
    fullName?: string | undefined;
    /** Identity provider source. */
    idPsource?: string | undefined;
    /** Coins this user has. */
    coins?: number;
}

/** Card. */
export class CardModel implements ICardModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Description. */
    description?: string | undefined;
    /** Up attack. */
    upAttack?: number;
    /** Right attack. */
    rightAttack?: number;
    /** Down attack. */
    downAttack?: number;
    /** Left attack. */
    leftAttack?: number;
    /** Health. */
    health?: number;
    /** Attack. */
    attack?: number;
    /** Defence. */
    defence?: number;
    /** Total stats. */
    totalStats?: number;
    /** Is favourited. */
    isFavourited?: boolean;
    /** Rarity. */
    rarity?: RarityModel | undefined;

    constructor(data?: ICardModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.upAttack = _data["upAttack"];
            this.rightAttack = _data["rightAttack"];
            this.downAttack = _data["downAttack"];
            this.leftAttack = _data["leftAttack"];
            this.health = _data["health"];
            this.attack = _data["attack"];
            this.defence = _data["defence"];
            this.totalStats = _data["totalStats"];
            this.isFavourited = _data["isFavourited"];
            this.rarity = _data["rarity"] ? RarityModel.fromJS(_data["rarity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CardModel {
        data = typeof data === 'object' ? data : {};
        let result = new CardModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["upAttack"] = this.upAttack;
        data["rightAttack"] = this.rightAttack;
        data["downAttack"] = this.downAttack;
        data["leftAttack"] = this.leftAttack;
        data["health"] = this.health;
        data["attack"] = this.attack;
        data["defence"] = this.defence;
        data["totalStats"] = this.totalStats;
        data["isFavourited"] = this.isFavourited;
        data["rarity"] = this.rarity ? this.rarity.toJSON() : <any>undefined;
        return data; 
    }
}

/** Card. */
export interface ICardModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Description. */
    description?: string | undefined;
    /** Up attack. */
    upAttack?: number;
    /** Right attack. */
    rightAttack?: number;
    /** Down attack. */
    downAttack?: number;
    /** Left attack. */
    leftAttack?: number;
    /** Health. */
    health?: number;
    /** Attack. */
    attack?: number;
    /** Defence. */
    defence?: number;
    /** Total stats. */
    totalStats?: number;
    /** Is favourited. */
    isFavourited?: boolean;
    /** Rarity. */
    rarity?: RarityModel | undefined;
}

/** Rarity. */
export class RarityModel implements IRarityModel {
    /** Id. */
    id?: Rarity;
    /** Name. */
    name?: string | undefined;
    /** Frequency. */
    frequency?: number;

    constructor(data?: IRarityModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.frequency = _data["frequency"];
        }
    }

    static fromJS(data: any): RarityModel {
        data = typeof data === 'object' ? data : {};
        let result = new RarityModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["frequency"] = this.frequency;
        return data; 
    }
}

/** Rarity. */
export interface IRarityModel {
    /** Id. */
    id?: Rarity;
    /** Name. */
    name?: string | undefined;
    /** Frequency. */
    frequency?: number;
}

/** Rarity. */
export enum Rarity {
    Common = 1,
    Uncommon = 2,
    Rare = 3,
    Epic = 4,
    Legendary = 5,
}

/** Card pack. */
export class CardPackModel implements ICardPackModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Description. */
    description?: string | undefined;

    constructor(data?: ICardPackModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CardPackModel {
        data = typeof data === 'object' ? data : {};
        let result = new CardPackModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

/** Card pack. */
export interface ICardPackModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Description. */
    description?: string | undefined;
}

/** Card collection. */
export class CardCollectionModel implements ICardCollectionModel {
    /** Id. */
    id?: number;
    /** Card id. */
    cardId?: number;
    /** User id. */
    userId?: number;
    /** Card. */
    card?: CardModel | undefined;

    constructor(data?: ICardCollectionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cardId = _data["cardId"];
            this.userId = _data["userId"];
            this.card = _data["card"] ? CardModel.fromJS(_data["card"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CardCollectionModel {
        data = typeof data === 'object' ? data : {};
        let result = new CardCollectionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cardId"] = this.cardId;
        data["userId"] = this.userId;
        data["card"] = this.card ? this.card.toJSON() : <any>undefined;
        return data; 
    }
}

/** Card collection. */
export interface ICardCollectionModel {
    /** Id. */
    id?: number;
    /** Card id. */
    cardId?: number;
    /** User id. */
    userId?: number;
    /** Card. */
    card?: CardModel | undefined;
}

/** Deck. */
export class DeckModel implements IDeckModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Description. */
    description?: string | undefined;
    /** Max cards. */
    maxCards?: number;
    /** Is favourited. */
    isFavourited?: boolean;
    /** List of cards. */
    cards?: DeckCardModel[] | undefined;

    constructor(data?: IDeckModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.maxCards = _data["maxCards"];
            this.isFavourited = _data["isFavourited"];
            if (Array.isArray(_data["cards"])) {
                this.cards = [] as any;
                for (let item of _data["cards"])
                    this.cards!.push(DeckCardModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeckModel {
        data = typeof data === 'object' ? data : {};
        let result = new DeckModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["maxCards"] = this.maxCards;
        data["isFavourited"] = this.isFavourited;
        if (Array.isArray(this.cards)) {
            data["cards"] = [];
            for (let item of this.cards)
                data["cards"].push(item.toJSON());
        }
        return data; 
    }
}

/** Deck. */
export interface IDeckModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Description. */
    description?: string | undefined;
    /** Max cards. */
    maxCards?: number;
    /** Is favourited. */
    isFavourited?: boolean;
    /** List of cards. */
    cards?: DeckCardModel[] | undefined;
}

/** Deck caard. */
export class DeckCardModel implements IDeckCardModel {
    /** Card collection id. */
    cardCollectionId?: number;
    /** Card. */
    card?: CardModel | undefined;

    constructor(data?: IDeckCardModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cardCollectionId = _data["cardCollectionId"];
            this.card = _data["card"] ? CardModel.fromJS(_data["card"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DeckCardModel {
        data = typeof data === 'object' ? data : {};
        let result = new DeckCardModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cardCollectionId"] = this.cardCollectionId;
        data["card"] = this.card ? this.card.toJSON() : <any>undefined;
        return data; 
    }
}

/** Deck caard. */
export interface IDeckCardModel {
    /** Card collection id. */
    cardCollectionId?: number;
    /** Card. */
    card?: CardModel | undefined;
}

/** Model for creating a new deck. */
export class DeckCreateModel implements IDeckCreateModel {
    /** Name of deck. */
    name?: string | undefined;
    /** Description of deck. */
    description?: string | undefined;

    constructor(data?: IDeckCreateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): DeckCreateModel {
        data = typeof data === 'object' ? data : {};
        let result = new DeckCreateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

/** Model for creating a new deck. */
export interface IDeckCreateModel {
    /** Name of deck. */
    name?: string | undefined;
    /** Description of deck. */
    description?: string | undefined;
}

/** Game. */
export class GameModel implements IGameModel {
    /** Id. */
    id?: number;
    /** Sart time. */
    startTime?: Date;
    /** End time. */
    endTime?: Date | undefined;
    /** Users. */
    userIds?: number[] | undefined;
    /** Current user id. */
    currentUserId?: number | undefined;
    /** Winner user id. */
    winnerUserId?: number | undefined;
    /** Columns. */
    columns?: number;
    /** Rows. */
    rows?: number;
    /** Game type. */
    type?: GameType;
    /** Maximum number of people who can play the game. */
    maxUsers?: number;

    constructor(data?: IGameModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
            this.currentUserId = _data["currentUserId"];
            this.winnerUserId = _data["winnerUserId"];
            this.columns = _data["columns"];
            this.rows = _data["rows"];
            this.type = _data["type"];
            this.maxUsers = _data["maxUsers"];
        }
    }

    static fromJS(data: any): GameModel {
        data = typeof data === 'object' ? data : {};
        let result = new GameModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["currentUserId"] = this.currentUserId;
        data["winnerUserId"] = this.winnerUserId;
        data["columns"] = this.columns;
        data["rows"] = this.rows;
        data["type"] = this.type;
        data["maxUsers"] = this.maxUsers;
        return data; 
    }
}

/** Game. */
export interface IGameModel {
    /** Id. */
    id?: number;
    /** Sart time. */
    startTime?: Date;
    /** End time. */
    endTime?: Date | undefined;
    /** Users. */
    userIds?: number[] | undefined;
    /** Current user id. */
    currentUserId?: number | undefined;
    /** Winner user id. */
    winnerUserId?: number | undefined;
    /** Columns. */
    columns?: number;
    /** Rows. */
    rows?: number;
    /** Game type. */
    type?: GameType;
    /** Maximum number of people who can play the game. */
    maxUsers?: number;
}

/** Type of game. */
export enum GameType {
    Standard = 1,
}

/** Model for creating a new game. */
export class GameCreateModel implements IGameCreateModel {
    /** Type of game. */
    type?: GameType;
    /** Deck to use. */
    deckId?: number;
    /** Users in game. */
    users?: UserModel[] | undefined;
    /** Max players in game. */
    maxPlayers?: number;
    /** Columns in game. */
    columns?: number;
    /** Rows in game. */
    rows?: number;

    constructor(data?: IGameCreateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.deckId = _data["deckId"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UserModel.fromJS(item));
            }
            this.maxPlayers = _data["maxPlayers"];
            this.columns = _data["columns"];
            this.rows = _data["rows"];
        }
    }

    static fromJS(data: any): GameCreateModel {
        data = typeof data === 'object' ? data : {};
        let result = new GameCreateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["deckId"] = this.deckId;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        data["maxPlayers"] = this.maxPlayers;
        data["columns"] = this.columns;
        data["rows"] = this.rows;
        return data; 
    }
}

/** Model for creating a new game. */
export interface IGameCreateModel {
    /** Type of game. */
    type?: GameType;
    /** Deck to use. */
    deckId?: number;
    /** Users in game. */
    users?: UserModel[] | undefined;
    /** Max players in game. */
    maxPlayers?: number;
    /** Columns in game. */
    columns?: number;
    /** Rows in game. */
    rows?: number;
}

/** Model for joining a game. */
export class GameJoinModel implements IGameJoinModel {
    /** User joining. */
    userId?: number;
    /** Deck to use. */
    deckId?: number;

    constructor(data?: IGameJoinModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.deckId = _data["deckId"];
        }
    }

    static fromJS(data: any): GameJoinModel {
        data = typeof data === 'object' ? data : {};
        let result = new GameJoinModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["deckId"] = this.deckId;
        return data; 
    }
}

/** Model for joining a game. */
export interface IGameJoinModel {
    /** User joining. */
    userId?: number;
    /** Deck to use. */
    deckId?: number;
}

/** Game play model. */
export class GamePlayModel implements IGamePlayModel {
    /** Game. */
    game?: GameModel | undefined;
    /** Cards played in game. */
    playedCards?: CardModel[] | undefined;
    /** Moves played in game. */
    moves?: MoveModel[] | undefined;
    /** Game deck id. */
    gameDeckId?: number;
    /** Game deck. */
    gameDeck?: GameDeckModel | undefined;

    constructor(data?: IGamePlayModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.game = _data["game"] ? GameModel.fromJS(_data["game"]) : <any>undefined;
            if (Array.isArray(_data["playedCards"])) {
                this.playedCards = [] as any;
                for (let item of _data["playedCards"])
                    this.playedCards!.push(CardModel.fromJS(item));
            }
            if (Array.isArray(_data["moves"])) {
                this.moves = [] as any;
                for (let item of _data["moves"])
                    this.moves!.push(MoveModel.fromJS(item));
            }
            this.gameDeckId = _data["gameDeckId"];
            this.gameDeck = _data["gameDeck"] ? GameDeckModel.fromJS(_data["gameDeck"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GamePlayModel {
        data = typeof data === 'object' ? data : {};
        let result = new GamePlayModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["game"] = this.game ? this.game.toJSON() : <any>undefined;
        if (Array.isArray(this.playedCards)) {
            data["playedCards"] = [];
            for (let item of this.playedCards)
                data["playedCards"].push(item.toJSON());
        }
        if (Array.isArray(this.moves)) {
            data["moves"] = [];
            for (let item of this.moves)
                data["moves"].push(item.toJSON());
        }
        data["gameDeckId"] = this.gameDeckId;
        data["gameDeck"] = this.gameDeck ? this.gameDeck.toJSON() : <any>undefined;
        return data; 
    }
}

/** Game play model. */
export interface IGamePlayModel {
    /** Game. */
    game?: GameModel | undefined;
    /** Cards played in game. */
    playedCards?: CardModel[] | undefined;
    /** Moves played in game. */
    moves?: MoveModel[] | undefined;
    /** Game deck id. */
    gameDeckId?: number;
    /** Game deck. */
    gameDeck?: GameDeckModel | undefined;
}

/** Represents a move by a player. */
export class MoveModel implements IMoveModel {
    /** The game to make a move on. */
    gameId?: number;
    /** The card id played. */
    cardId?: number;
    /** The card to play. */
    gameDeckCardCollectionId?: number;
    /** Zero based index of the row. */
    row?: number;
    /** Zero based index of the column. */
    column?: number;
    /** The user making the move. */
    userId?: number;
    /** Time the move was made. */
    startTime?: Date;

    constructor(data?: IMoveModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gameId = _data["gameId"];
            this.cardId = _data["cardId"];
            this.gameDeckCardCollectionId = _data["gameDeckCardCollectionId"];
            this.row = _data["row"];
            this.column = _data["column"];
            this.userId = _data["userId"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MoveModel {
        data = typeof data === 'object' ? data : {};
        let result = new MoveModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gameId"] = this.gameId;
        data["cardId"] = this.cardId;
        data["gameDeckCardCollectionId"] = this.gameDeckCardCollectionId;
        data["row"] = this.row;
        data["column"] = this.column;
        data["userId"] = this.userId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        return data; 
    }
}

/** Represents a move by a player. */
export interface IMoveModel {
    /** The game to make a move on. */
    gameId?: number;
    /** The card id played. */
    cardId?: number;
    /** The card to play. */
    gameDeckCardCollectionId?: number;
    /** Zero based index of the row. */
    row?: number;
    /** Zero based index of the column. */
    column?: number;
    /** The user making the move. */
    userId?: number;
    /** Time the move was made. */
    startTime?: Date;
}

/** Deck for use within a game. */
export class GameDeckModel implements IGameDeckModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Description. */
    description?: string | undefined;
    /** Game user id. */
    gameUserId?: number;
    /** Cards in game deck. */
    cardCollection?: GameDeckCardCollectionModel[] | undefined;

    constructor(data?: IGameDeckModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.gameUserId = _data["gameUserId"];
            if (Array.isArray(_data["cardCollection"])) {
                this.cardCollection = [] as any;
                for (let item of _data["cardCollection"])
                    this.cardCollection!.push(GameDeckCardCollectionModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GameDeckModel {
        data = typeof data === 'object' ? data : {};
        let result = new GameDeckModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["gameUserId"] = this.gameUserId;
        if (Array.isArray(this.cardCollection)) {
            data["cardCollection"] = [];
            for (let item of this.cardCollection)
                data["cardCollection"].push(item.toJSON());
        }
        return data; 
    }
}

/** Deck for use within a game. */
export interface IGameDeckModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Description. */
    description?: string | undefined;
    /** Game user id. */
    gameUserId?: number;
    /** Cards in game deck. */
    cardCollection?: GameDeckCardCollectionModel[] | undefined;
}

/** Card to use within a game deck. */
export class GameDeckCardCollectionModel implements IGameDeckCardCollectionModel {
    /** Id. */
    id?: number;
    /** Game deck id. */
    gameDeckId?: number;
    /** Card id. */
    cardId?: number;
    /** Card. */
    card?: CardModel | undefined;

    constructor(data?: IGameDeckCardCollectionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.gameDeckId = _data["gameDeckId"];
            this.cardId = _data["cardId"];
            this.card = _data["card"] ? CardModel.fromJS(_data["card"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GameDeckCardCollectionModel {
        data = typeof data === 'object' ? data : {};
        let result = new GameDeckCardCollectionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["gameDeckId"] = this.gameDeckId;
        data["cardId"] = this.cardId;
        data["card"] = this.card ? this.card.toJSON() : <any>undefined;
        return data; 
    }
}

/** Card to use within a game deck. */
export interface IGameDeckCardCollectionModel {
    /** Id. */
    id?: number;
    /** Game deck id. */
    gameDeckId?: number;
    /** Card id. */
    cardId?: number;
    /** Card. */
    card?: CardModel | undefined;
}

/** Store item. */
export class StoreItemModel implements IStoreItemModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Description. */
    description?: string | undefined;
    /** Cost. */
    cost?: number;
    /** Item count. */
    itemCount?: number;
    /** Expiry. */
    expiry?: Date | undefined;

    constructor(data?: IStoreItemModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.cost = _data["cost"];
            this.itemCount = _data["itemCount"];
            this.expiry = _data["expiry"] ? new Date(_data["expiry"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): StoreItemModel {
        data = typeof data === 'object' ? data : {};
        let result = new StoreItemModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["cost"] = this.cost;
        data["itemCount"] = this.itemCount;
        data["expiry"] = this.expiry ? this.expiry.toISOString() : <any>undefined;
        return data; 
    }
}

/** Store item. */
export interface IStoreItemModel {
    /** Id. */
    id?: number;
    /** Name. */
    name?: string | undefined;
    /** Description. */
    description?: string | undefined;
    /** Cost. */
    cost?: number;
    /** Item count. */
    itemCount?: number;
    /** Expiry. */
    expiry?: Date | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}